package com.birds.count.chrysolophuspictus.metric;

import com.birds.count.chrysolophuspictus.exception.ResourceNotFoundException;
import com.birds.count.chrysolophuspictus.wrapper.StatisticsWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Controller that handles queries about Metrics
 * for historic reason metrics are not deleted
 */
@RestController
@RequestMapping("/api")
public class MetricController {
    private final Logger LOGGER = LoggerFactory.getLogger(MetricController.class);

    private final MetricService metricService;

    @Autowired
    public MetricController(MetricService metricService) {
        this.metricService = metricService;
    }

    /**
     * Get endpoint to retrieve all metrics grouped by sensor id.
     *
     * @param sensorId - optional sensor id if request to retrieve all metrics for this sensor
     * @return Map<Integer, List < Metric>> - a collection of metrics grouped by sensor id.
     */
    @GetMapping("/metrics")
    public ResponseEntity<Map<Integer, List<Metric>>> getAllMetric(@RequestParam(value = "id", required = false) Integer sensorId) {

        final Map<Integer, List<Metric>> listMetric = metricService.getAllMetricsForSensor(sensorId);
        if (listMetric.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } else {
            return new ResponseEntity<>(listMetric, HttpStatus.OK);
        }
    }


    /**
     * POST endpoint to create a list of metrics for a given sensor if active
     *
     * @param sensorId - the id of the sensor that generated the List<Metric>
     * @param metrics  - list of metric generated by sensor with id sensorId to be processed
     * @return Map<String, List < Metric>> -  the Map contains report of the failed and successfully persisted metrics
     */
    @PostMapping("/metrics/sensor/{sensorId}")
    public ResponseEntity<Map<String, List<Metric>>> createMetrics(@PathVariable Integer sensorId, @RequestBody List<Metric> metrics) {

        Map<String, List<Metric>> reportPair = null;
        try {
            reportPair = metricService.batchUpdate(sensorId, metrics);
        } catch (ResourceNotFoundException ex) {
            LOGGER.debug("Not allowed to save metric without an active or existing sensor -> sensor id :: {}", sensorId);
        }
        if (Objects.nonNull(reportPair)) {
            return new ResponseEntity<>(reportPair, HttpStatus.CREATED);
        } else {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

    }

    /**
     * Get endpoint to generate statistics for humidity and temperature given an optional range or id
     *
     * @param range    - the range provide the period to filter within
     * @param sensorId - aggregation will only apply to this sensor if the id is provided
     * @return List<StatisticsWrapper> - list of StatisticsWrapper that hold statistics for a list of sensor metrics statistics
     */
    @GetMapping("/metrics/stats")
    public ResponseEntity<List<StatisticsWrapper>> getHumidityAndTemperatureStatistics(@RequestParam(value = "range", required = false) String range, @RequestParam(value = "id", required = false) Integer sensorId) {
        LOGGER.info("Call to generate statistics");

        List<StatisticsWrapper> statisticsWrappers = metricService.getHumidityAndTemperatureStatistics(range, sensorId);
        return new ResponseEntity<>(statisticsWrappers, HttpStatus.OK);
    }

}